<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VISWA'S CREATION - Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .splash-screen {
            text-align: center;
            animation: fadeIn 1.5s ease-in;
        }

        .main-title {
            font-size: 48px;
            color: #00ffff;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 24px;
            color: #fff;
            font-style: italic;
            margin-bottom: 30px;
        }

        .loading {
            font-size: 18px;
            color: #00ffff;
        }

        .game-container {
            display: none;
            flex-direction: column;
            align-items: center;
        }

        .game-board {
            border: 2px solid #00ffff;
            background: #111;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 15px 20px;
            background: #333;
            color: #fff;
            border: 2px solid #00ffff;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
        }

        .control-btn:hover {
            background: #555;
        }

        .control-btn:active {
            background: #00ffff;
            color: #000;
        }

        .score-panel {
            margin-bottom: 20px;
            text-align: center;
        }

        .score-item {
            display: inline-block;
            margin: 0 20px;
            font-size: 18px;
        }

        .game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            text-align: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 600px) {
            .main-title { font-size: 32px; }
            .subtitle { font-size: 18px; }
            .control-btn { padding: 12px 16px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash" class="splash-screen">
        <h1 class="main-title">VISWA'S CREATION</h1>
        <h2 class="subtitle">TETRIS GAME</h2>
        <div class="loading">Loading...</div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer" class="game-container">
        <div class="score-panel">
            <div class="score-item">Score: <span id="score">0</span></div>
            <div class="score-item">Level: <span id="level">1</span></div>
            <div class="score-item">Lines: <span id="lines">0</span></div>
        </div>
        
        <canvas id="gameBoard" class="game-board" width="400" height="600"></canvas>
        
        <div class="controls">
            <button class="control-btn" onclick="tetris.moveLeft()">← Left</button>
            <button class="control-btn" onclick="tetris.rotate()">↻ Rotate</button>
            <button class="control-btn" onclick="tetris.moveRight()">Right →</button>
            <button class="control-btn" onclick="tetris.drop()">↓ Drop</button>
            <button class="control-btn" onclick="tetris.togglePause()">⏸ Pause</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOver" class="game-over">
        <h2 style="color: #ff0000;">GAME OVER</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="control-btn" onclick="tetris.restart()">New Game</button>
    </div>

    <script>
        // Tetris Game Implementation
        const tetris = {
            canvas: null,
            ctx: null,
            grid: [],
            currentPiece: null,
            score: 0,
            level: 1,
            lines: 0,
            gameRunning: false,
            paused: false,
            dropTime: 0,
            dropInterval: 1000,

            // Tetris pieces
            pieces: [
                // I-piece
                [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                // O-piece
                [
                    [1, 1],
                    [1, 1]
                ],
                // T-piece
                [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                // S-piece
                [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                // Z-piece
                [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                // J-piece
                [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                // L-piece
                [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ]
            ],

            colors: ['#00ffff', '#ffff00', '#800080', '#00ff00', '#ff0000', '#0000ff', '#ffa500'],

            init() {
                // Show splash screen for 3 seconds
                setTimeout(() => {
                    document.getElementById('splash').style.display = 'none';
                    document.getElementById('gameContainer').style.display = 'flex';
                    this.startGame();
                }, 3000);
            },

            startGame() {
                this.canvas = document.getElementById('gameBoard');
                this.ctx = this.canvas.getContext('2d');
                
                // Initialize grid (20 rows, 10 columns)
                this.grid = Array(20).fill().map(() => Array(10).fill(0));
                
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.gameRunning = true;
                this.paused = false;
                
                this.spawnPiece();
                this.gameLoop();
                
                // Add keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning || this.paused) return;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.moveLeft();
                            break;
                        case 'ArrowRight':
                            this.moveRight();
                            break;
                        case 'ArrowDown':
                            this.drop();
                            break;
                        case 'ArrowUp':
                            this.rotate();
                            break;
                        case ' ':
                            this.togglePause();
                            break;
                    }
                });
            },

            spawnPiece() {
                const pieceIndex = Math.floor(Math.random() * this.pieces.length);
                this.currentPiece = {
                    shape: this.pieces[pieceIndex],
                    x: 3,
                    y: 0,
                    color: this.colors[pieceIndex]
                };
                
                if (this.checkCollision(this.currentPiece.x, this.currentPiece.y, this.currentPiece.shape)) {
                    this.gameOver();
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;
                
                const now = Date.now();
                
                if (now - this.dropTime > this.dropInterval && !this.paused) {
                    this.moveDown();
                    this.dropTime = now;
                }
                
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            },

            moveLeft() {
                if (this.canMove(this.currentPiece.x - 1, this.currentPiece.y, this.currentPiece.shape)) {
                    this.currentPiece.x--;
                }
            },

            moveRight() {
                if (this.canMove(this.currentPiece.x + 1, this.currentPiece.y, this.currentPiece.shape)) {
                    this.currentPiece.x++;
                }
            },

            moveDown() {
                if (this.canMove(this.currentPiece.x, this.currentPiece.y + 1, this.currentPiece.shape)) {
                    this.currentPiece.y++;
                } else {
                    this.placePiece();
                    this.clearLines();
                    this.spawnPiece();
                }
            },

            drop() {
                while (this.canMove(this.currentPiece.x, this.currentPiece.y + 1, this.currentPiece.shape)) {
                    this.currentPiece.y++;
                }
            },

            rotate() {
                const rotated = this.rotatePiece(this.currentPiece.shape);
                if (this.canMove(this.currentPiece.x, this.currentPiece.y, rotated)) {
                    this.currentPiece.shape = rotated;
                }
            },

            rotatePiece(piece) {
                const rows = piece.length;
                const cols = piece[0].length;
                const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        rotated[x][rows - 1 - y] = piece[y][x];
                    }
                }
                
                return rotated;
            },

            canMove(newX, newY, shape) {
                return !this.checkCollision(newX, newY, shape);
            },

            checkCollision(x, y, shape) {
                for (let py = 0; py < shape.length; py++) {
                    for (let px = 0; px < shape[py].length; px++) {
                        if (shape[py][px]) {
                            const newX = x + px;
                            const newY = y + py;
                            
                            if (newX < 0 || newX >= 10 || newY >= 20) return true;
                            if (newY >= 0 && this.grid[newY][newX]) return true;
                        }
                    }
                }
                return false;
            },

            placePiece() {
                for (let py = 0; py < this.currentPiece.shape.length; py++) {
                    for (let px = 0; px < this.currentPiece.shape[py].length; px++) {
                        if (this.currentPiece.shape[py][px]) {
                            const x = this.currentPiece.x + px;
                            const y = this.currentPiece.y + py;
                            if (y >= 0) {
                                this.grid[y][x] = this.currentPiece.color;
                            }
                        }
                    }
                }
            },

            clearLines() {
                let linesCleared = 0;
                
                for (let y = this.grid.length - 1; y >= 0; y--) {
                    if (this.grid[y].every(cell => cell !== 0)) {
                        this.grid.splice(y, 1);
                        this.grid.unshift(Array(10).fill(0));
                        linesCleared++;
                        y++; // Check the same row again
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += linesCleared * 100 * this.level;
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
                    this.updateScore();
                }
            },

            updateScore() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lines').textContent = this.lines;
            },

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.drawGrid();
                
                // Draw placed pieces
                for (let y = 0; y < this.grid.length; y++) {
                    for (let x = 0; x < this.grid[y].length; x++) {
                        if (this.grid[y][x]) {
                            this.drawBlock(x, y, this.grid[y][x]);
                        }
                    }
                }
                
                // Draw current piece
                if (this.currentPiece) {
                    for (let py = 0; py < this.currentPiece.shape.length; py++) {
                        for (let px = 0; px < this.currentPiece.shape[py].length; px++) {
                            if (this.currentPiece.shape[py][px]) {
                                const x = this.currentPiece.x + px;
                                const y = this.currentPiece.y + py;
                                if (y >= 0) {
                                    this.drawBlock(x, y, this.currentPiece.color);
                                }
                            }
                        }
                    }
                }
            },

            drawGrid() {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x <= 10; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * 40, 0);
                    this.ctx.lineTo(x * 40, 600);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= 20; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * 30);
                    this.ctx.lineTo(400, y * 30);
                    this.ctx.stroke();
                }
            },

            drawBlock(x, y, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x * 40 + 1, y * 30 + 1, 38, 28);
                
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x * 40 + 1, y * 30 + 1, 38, 28);
            },

            togglePause() {
                this.paused = !this.paused;
                document.querySelector('.control-btn:last-child').textContent = 
                    this.paused ? '▶ Resume' : '⏸ Pause';
            },

            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            },

            restart() {
                document.getElementById('gameOver').style.display = 'none';
                this.startGame();
            }
        };

        // Start the game when page loads
        window.addEventListener('load', () => {
            tetris.init();
        });
    </script>
</body>
</html> 